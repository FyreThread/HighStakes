{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\n\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  int systemTime = Brain.Timer.systemHighResolution();\n  double batteryCurrent = Brain.Battery.current();\n  double batteryVoltage = Brain.Battery.voltage(voltageUnits::mV);\n\n  // Combine these values into a single integer\n  int seed = int(batteryVoltage + batteryCurrent * 100) + systemTime;\n\n  // Set the seed\n  srand(seed);\n}\n\n\n\nvoid vexcodeInit() {\n\n  //Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"v5.h\"\n#include \"v5_vcs.h\"\nusing namespace vex;\n\n\n// Define motors and other devices below\nmotor intake = motor(PORT9, ratio6_1, false);\n\nmotor wallStakeA = motor(PORT11, ratio18_1, true);\nmotor wallStakeB = motor(PORT12, ratio18_1, false);\nmotor_group wallStake = motor_group(wallStakeA, wallStakeB);\n\nmotor leftMotorA = motor(PORT1, ratio6_1, true);\nmotor leftMotorB = motor(PORT2, ratio6_1, true);\nmotor leftMotorC = motor(PORT3, ratio6_1, true);\nmotor_group LeftDriveSmart = motor_group(leftMotorA, leftMotorB, leftMotorC);\nmotor rightMotorA = motor(PORT5, ratio6_1, false);\nmotor rightMotorB = motor(PORT6, ratio6_1, false);\nmotor rightMotorC = motor(PORT7, ratio6_1, false);\nmotor_group RightDriveSmart = motor_group(rightMotorA, rightMotorB, rightMotorC);\ninertial Inertial = inertial(PORT8);\nsmartdrive Drivetrain = smartdrive(LeftDriveSmart, RightDriveSmart, Inertial, 219, 304.8, 266.7, mm, 0.75);\n\ndigital_out actuator1 = digital_out(Brain.ThreeWirePort.A);\ndigital_out doinker = digital_out(Brain.ThreeWirePort.H);\n\ncontroller Controller1 = controller(primary);\n\ncompetition Competition = competition();\n\n// Driver Control Code\nvoid driverControl() {\n  while(1==1) {\n      // calculate the drivetrain motor velocities from the controller joystick axies\n      // left = Axis3 + Axis4\n      // right = Axis3 - Axis4\n      int drivetrainLeftSideSpeed = Controller1.Axis3.position() + Controller1.Axis4.position() + Controller1.Axis1.position();\n      int drivetrainRightSideSpeed = Controller1.Axis3.position() - Controller1.Axis4.position() - Controller1.Axis1.position();\n\n        LeftDriveSmart.setVelocity(drivetrainLeftSideSpeed, percent);\n        LeftDriveSmart.spin(forward);\n\n        RightDriveSmart.setVelocity(drivetrainRightSideSpeed, percent);\n        RightDriveSmart.spin(forward);\n  }\n}\n\n// Control Functions\nvoid intakeForward() {\n    intake.spin(forward);\n}\nvoid intakeReverse() {\n    intake.spin(reverse);\n}\nvoid intakeStop() {\n    intake.stop();\n}\nvoid wallStakePrime() {\n    wallStake.spinFor(180, degrees);\n}\nvoid wallStakeScore() {\n    wallStake.spinFor(500, degrees);\n}\nvoid wallStakeForward() {\n    wallStake.spin(forward);\n}\nvoid wallStakeStow() {\n    wallStake.spin(reverse);\n}\nvoid wallStakeStop() {\n    wallStake.stop();\n}\nvoid mobileGrab() {\n    actuator1.set(true);\n}\nvoid mobileRelease() {\n    actuator1.set(false);\n}\nvoid doinkerOut() {\n    doinker.set(true);\n}\nvoid doinkerIn() {\n    doinker.set(false);\n}\n\n// Starting Settings\nvoid initalize() {\n    Inertial.calibrate();\n    Inertial.setHeading(0, degrees);\n    actuator1.set(false);\n    doinker.set(false);\n    Drivetrain.setDriveVelocity(150, percent);\n    Drivetrain.setTurnVelocity(70, percent);\n    Drivetrain.setStopping(brake);\n    intake.setVelocity(150, percent);\n    wallStake.setVelocity(150,percent);\n    wallStake.setStopping(brake);\n}\n\n// Button Controls\nvoid buttons() {\n  Controller1.ButtonR2.pressed(intakeForward);\n    Controller1.ButtonR2.released(intakeStop);\n    Controller1.ButtonL2.pressed(intakeReverse);\n    Controller1.ButtonL2.released(intakeStop);\n    Controller1.ButtonA.pressed(wallStakePrime);\n    Controller1.ButtonX.pressed(wallStakeScore);\n    Controller1.ButtonY.pressed(wallStakeStow);\n    Controller1.ButtonY.released(wallStakeStop);\n    Controller1.ButtonB.pressed(wallStakeForward);\n    Controller1.ButtonB.released(wallStakeStop);\n    Controller1.ButtonL1.pressed(mobileGrab);\n    Controller1.ButtonR1.pressed(mobileRelease);\n    Controller1.ButtonLeft.pressed(doinkerOut);\n    Controller1.ButtonUp.pressed(doinkerIn);\n}\n//By Gllitchh\n\nfloat ActualHeading, TargetHeading, error, MotorSpeed;\n\n// Left P Loop \nvoid turnLeftDegrees(double targetDegrees) {\n  // Proportional gain (Turn to much, make smaller, Turn to little, make bigger)\n  double kP = 0.432;//432\n\n  // Dead zone for the loop\n  int deadzone = 2;\n\n  //The slowist speed the Loop start with.\n  double minMotorSpeed = 5.0;\n\n  // Calculate target heading\n  double targetHeading = Drivetrain.heading() - targetDegrees;\n\n  // Ensure targetHeading is within the range [0, 360)\n  if (targetHeading < 0) {\n    targetHeading += 360.0;\n  } else if (targetHeading >= 360.0) {\n    targetHeading -= 360.0;\n  }\n\n  // Turn left until the target heading is reached\n  while (true) {\n    // Calculate error\n    double error = targetHeading - Drivetrain.heading();\n    \n    // Ensure error is within the range [-180, 180)\n    if (error < -180.0) {\n      error += 360.0;\n    } else if (error >= 180.0) {\n      error -= 360.0;\n    }\n\n    // Apply dead zone\n    if (fabs(error) < deadzone) {\n      error = 0.0;\n    }\n    \n    // Calculate motor speed based on error\n    double motorSpeed = error * kP;\n\n    // Decrease motor speed as error decreases\n    motorSpeed *= fabs(error / targetDegrees);\n\n  if (fabs(motorSpeed) < minMotorSpeed) {\n    motorSpeed = copysign(minMotorSpeed, motorSpeed);\n  }\n\n    // Set the motor speeds for left turn\n    LeftDriveSmart.setVelocity(motorSpeed, percent);\n    RightDriveSmart.setVelocity(-motorSpeed, percent); // Reverse the direction\n\n    // Spin the motors for left turn\n    LeftDriveSmart.spin(forward);\n    RightDriveSmart.spin(forward);\n\n    // Break the loop if the target heading is reached\n    if (fabs(error) < 2.0) {\n      Drivetrain.setDriveVelocity(150.0, percent);\n      Drivetrain.stop();\n      break;\n    }\n    \n    // Wait for a short duration\n    wait(5, msec);\n  }\n\n  // Stop the drivetrain\n  Drivetrain.stop();\n}\n\n//Right P loop\nvoid turnRightDegrees(double targetDegrees) {\n  // Proportional gain (Turn to much, make smaller, Turn to little, make bigger)\n  double kP = 0.432;//432\n\n  // Dead zone for the Loop\n  int deadzone = 2;\n\n  //The slowist speed the loop will start with  \n  double minMotorSpeed = 5.0;\n\n  // Calculate target heading\n  double targetHeading = Drivetrain.heading() + targetDegrees;\n\n  // Ensure targetHeading is within the range [0, 360)\n  if (targetHeading < 0) {\n    targetHeading += 360.0;\n  } else if (targetHeading >= 360.0) {\n    targetHeading -= 360.0;\n  }\n\n  // Turn right until the target heading is reached\n  while (true) {\n    // Calculate error\n    double error = targetHeading - Drivetrain.heading();\n    \n    // Ensure error is within the range [-180, 180)\n    if (error < -180.0) {\n      error += 360.0;\n    } else if (error >= 180.0) {\n      error -= 360.0;\n    }\n\n    // Apply dead zone\n    if (fabs(error) < deadzone) {\n      error = 0.0;\n    }\n    \n    // Calculate motor speed based on error\n    double motorSpeed = error * kP;\n\n    // Decrease motor speed as error decreases\n    motorSpeed *= fabs(error / targetDegrees);\n\n   if (fabs(motorSpeed) < minMotorSpeed) {\n     motorSpeed = copysign(minMotorSpeed, motorSpeed);\n    }\n\n    // Set the motor speeds for right turn\n    LeftDriveSmart.setVelocity(motorSpeed, percent);\n    RightDriveSmart.setVelocity(-motorSpeed, percent); // Reverse the direction\n\n    // Spin the motors for right turn\n    LeftDriveSmart.spin(forward);\n    RightDriveSmart.spin(forward);\n\n    // Break the loop if the target heading is reached\n    if (fabs(error) < 2.0) {\n      Drivetrain.stop();\n      Drivetrain.setDriveVelocity(150.0, percent);\n      break;\n    }\n    \n    // Wait for a short duration\n    wait(5, msec);\n  }\n\n  // Stop the drivetrain\n  Drivetrain.stop();\n}\n\n\n\n\n\n\n\n\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       main.cpp                                                  */\n/*    Author:       Alex Caroon                                               */\n/*    Created:      10/3/2024, 2:56:54 PM                                     */\n/*    Description:  High Stakes 9144G Code (Fun Sold Separately)              */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n#include \"vex.h\"\n#include <iostream>\nusing namespace vex;\n\n// Autonomous\nvoid autonomous() {\n  mobileRelease();\n  Drivetrain.setDriveVelocity(50, percent);\n  Drivetrain.driveFor(reverse, 30, inches);\n  Drivetrain.setDriveVelocity(20, percent);\n  mobileGrab();\n  Drivetrain.driveFor(reverse, 12, inches);\n  wait(.25, seconds);\n  mobileGrab();\n  intake.spinFor(forward, 2, turns);\n  intake.spinFor(reverse, .5, turns);\n  intake.spinFor(forward, 2.5, turns);\n  mobileRelease();\n  wait(.125, seconds);\n  Drivetrain.driveFor(forward, 13, inches);\n  turnRightDegrees(35);\n  Drivetrain.setDriveVelocity(40, percent);\n  Drivetrain.driveFor(reverse, 29, inches);\n  mobileGrab();\n  turnLeftDegrees(50);\n  intake.spin(forward);\n  Drivetrain.driveFor(forward, 8, inches);\n  turnRightDegrees(15);\n  Drivetrain.driveFor(forward, 12, inches);\n  turnRightDegrees(105);\n  intake.spinFor(reverse, 1, turns, false);\n  Drivetrain.driveFor(forward, 20, inches);\n  turnRightDegrees(25);\n  intake.spin(forward);\n  wallStakeScore();\n  intake.stop();\n  Drivetrain.setDriveVelocity(20, percent);\n  Drivetrain.driveFor(forward, 11.25, inches);\n}\n\nint main() {\n  intake.setVelocity(100, percent);\n  initalize();\n  Competition.autonomous(autonomous);\n}","textLanguage":"cpp","robotConfig":[],"slot":2,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}